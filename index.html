<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <style>
    
    body{
  margin:0;
  background: radial-gradient(circle at 50% 20%, #0f172a, #020617 70%);
  font-family: "Segoe UI", Arial, sans-serif;
  color:#e5e7eb;
  padding-top:80px; /* â­ í—¤ë” ë†’ì´ë§Œí¼ ë°€ì–´ì¤Œ (í•„ìˆ˜) */
}


    .container{
  max-width:1200px;
  width:100%;
  margin:0 auto;
  padding:16px;
  box-sizing:border-box;

  transition:margin-left .35s cubic-bezier(.25,.8,.25,1);
}

    .panel{
  padding:22px;
  margin-bottom:18px;
  background:rgba(25,35,60,0.55);
  border-radius:20px;

  backdrop-filter:blur(10px);

  border:1px solid rgba(96,165,250,.18);

  box-shadow:
    0 8px 30px rgba(0,0,0,.55),
    inset 0 0 0 1px rgba(255,255,255,.03);

  transition:.25s;
}

    .panel-title {
  margin-bottom:10px;
  color:#34d399;
  font-weight:bold;
    }
    .stats-summary {
  margin-bottom: 16px;
  padding: 12px;
  background: #0a0a0a;
  border: 1px solid #555;
  border-radius: 8px;
  color: white;
  font-size: 14px;
  line-height: 1.5;
}
    .options {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

/* ê¸°ë³¸ ë²„íŠ¼ */
.btn {
  flex:0 0 auto;
  padding: 6px 12px;
  border-radius: 6px;
  border: 1px solid #1f6f78;
  background: linear-gradient(135deg, #0f2a2a, #0b1f1f);
  color: white;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
}

/* hover */
.btn:hover {
  background: linear-gradient(135deg, #123838, #0f2a2a);
  box-shadow: 0 0 10px rgba(0, 255, 220, 0.35);
  transform: translateY(-1px);
}

/* í´ë¦­ */
.btn:active {
  transform: translateY(1px);
  box-shadow: none;
}

/* ì„ íƒ ìƒíƒœ (í•µì‹¬) */
.btn.active {
  background: linear-gradient(135deg, #1fbfb8, #119e97);
  border-color: #37fff0;
  color: #001a18;
  box-shadow: 0 0 14px rgba(0, 255, 220, 0.65);
}

/* ë¹„í™œì„± */
.btn.disabled {
  opacity: 0.28;
  pointer-events: none;
  border-color: #2a2a2a;
  color: #4b4b4b;
  background: #111;
  box-shadow: none;
  transform: none;
}
   
    /* ê²°ê³¼ ì¹´ë“œ ë˜í¼ */
.result-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 16px;
}

/* ì¹´ë“œ */
.result-card {
  border: 1px solid #6b6430;
  background: linear-gradient(#161616, #0d0d0d);
  padding: 8px 10px;
  border-radius: 4px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
}

/* ì´ë¦„ */
.result-name {
  color: #f1dc55;
  font-size: 13px;
  font-weight: 700;
  margin-bottom: 4px;
}

/* ì˜µì…˜ í…ìŠ¤íŠ¸ */
.result-option {
  font-size: 13px;
  color: #cfcfcf;
  line-height: 1.4;
}

/* ê²°ê³¼ ì—†ìŒ */
.hint {
  color: #777;
  font-size: 20px;
}
.result-card {
  background: linear-gradient(135deg, #111, #1b1b1b);
  border: 1px solid #3a3a3a;
  border-radius: 8px;
  padding: 14px;
  color: #fff;
  width: 300px;
  box-sizing: border-box;
}

/* ìƒë‹¨ */
.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.card-title {
  font-size: 15px;
  font-weight: 700;
  color: #fff;
}

.card-grade {
  font-size: 12px;
  padding: 3px 8px;
  border-radius: 7px;
  font-weight:600;
}

.card-options {
  display: flex;
  gap: 6px;
  margin: 8px 0;
  flex-wrap: wrap;
}

.option-tag {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  background: #2a2a2a;
  color: #ccc;
  transition: 0.2s;
}

.option-tag.selected {
  background: #88FF88;
  color: #000;
  font-weight: 600;
}

/* ì§€ì—­ */
.card-desc {
  font-size: 12px;
  color: #aaa;
}
.result-list {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;   /* â­ ì´ê²Œ í•µì‹¬ */
}
.result-card {
  background: linear-gradient(#151515, #0e0e0e);
  border: 1px solid #333;
  border-radius: 10px;
  padding: 14px;
  box-sizing: border-box;
}

/* 6ì„± ë±ƒì§€ */
.grade-6 .card-grade{
  background: linear-gradient(145deg,#7a0000,#ff2a2a);
  color:#fff;
  border:1px solid #ff6b6b;
  box-shadow:
    0 0 6px rgba(255,60,60,.8),
    0 0 14px rgba(255,0,0,.45);
  font-weight:700;
}

/* 5ì„± ë±ƒì§€ */
.grade-5 .card-grade{
  background: linear-gradient(145deg,#5a4a00,#ffd700);
  color:#1a1a1a;
  border:1px solid #ffe066;
  box-shadow:
    0 0 6px rgba(255,215,0,.7),
    0 0 12px rgba(255,200,0,.45);
  font-weight:700;
}

/* 6ì„± */
.grade-6 {
  border-color: #ff2a2a;
  box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
}

/* 5ì„± */
.grade-5 {
  border-color: #ffd700;
  box-shadow: 0 0 12px rgba(255, 215, 0, 0.7);
}
.card-image {
  width: 100%;
  height: 160px;
  overflow: hidden;
  border-radius: 8px;
  margin-bottom: 8px;
}

.card-image img {
  width: 100%;
  height: 100%;
  object-fit: contain;   /* ë¹„ìœ¨ ìœ ì§€í•˜ë©° ê½‰ ì±„ì›€ */
  display: block;
}
/**.result-card.excluded {
  filter: grayscale(100%);
  opacity: 0.35;
  transform: scale(0.97);
  transition: 0.2s;
} **/

/* íŒŒë° ì™„ë£Œ í‘œì‹œ (ìš°í´ë¦­) */
.result-card.excluded{
  border: 2px solid #00ff88;
  box-shadow:
    0 0 8px rgba(0,255,120,0.6),
    0 0 18px rgba(0,255,120,0.35),
    inset 0 0 10px rgba(0,255,120,0.15);
  position: relative;
}

/* ì¢Œìƒë‹¨ ì²´í¬ í‘œì‹œ */
.result-card.excluded::after{
  content: "âœ” íšë“";
  position: absolute;
  top: 6px;
  left: 6px;
  font-size: 11px;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 6px;
  background: #00ff88;
  color: #002b16;
  box-shadow: 0 0 6px rgba(0,255,120,0.8);
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.header-buttons {
  display: flex;
  gap: 8px; /* ë²„íŠ¼ ì‚¬ì´ ê°„ê²© */
}
/* ì „ì²´ ì»¨í…Œì´ë„ˆ ë ˆì´ì•„ì›ƒ */
.toggle-wrapper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 5px 12px;
  border-radius: 8px;
  border: 1px solid #00cc44 none;
  width: fit-content;
  gap: 15px;
}

.data-btn{
  display:inline-block;
  padding:6px 14px;
  border-radius:20px;
  background:#1f2937;
  border:1px solid #374151;
  color: white;
  cursor:pointer;
  transition:.2s;
  margin-right:8px;
}

.data-btn:hover{
  background:#2c3b55;
  transform:translateY(-2px);
}


/* ìŠ¤ìœ„ì¹˜ ë³¸ì²´ */
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 22px;
}

/* ì²´í¬ë°•ìŠ¤ ìˆ¨ê¸°ê¸° */
.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.top-header{
  position:fixed;        /* â­ í•µì‹¬ (ê³ ì •) */
  top:0;
  left:0;
  width:100%;
  height:72px;
  z-index:9999;          /* ì¹´ë“œ ìœ„ì— í•­ìƒ ë³´ì´ê²Œ */

  display:flex;
  align-items:center;
  justify-content:center;

  background:linear-gradient(to bottom, rgba(2,6,23,.98), rgba(2,6,23,.65));
  border-bottom:1px solid rgba(96,165,250,.25);
  box-shadow:0 6px 35px rgba(0,0,0,.8);
  backdrop-filter: blur(8px); /* â­ ìœ ë¦¬ ëŠë‚Œ */
}

.top-header.scrolled{
  background:linear-gradient(to bottom, rgba(2,6,23,1), rgba(2,6,23,.85));
  box-shadow:0 8px 40px rgba(0,0,0,1);
}

/* ì¤‘ì•™ íƒ€ì´í‹€ */
.top-header .title{
  font-size:28px;
  font-weight:800;
  letter-spacing:2px;
  color:#93c5fd;
  text-shadow:
    0 0 10px rgba(96,165,250,.8),
    0 0 25px rgba(37,99,235,.6);
}

.back-btn{
  left:18px;
  top:50%;
  transform:translateY(-50%);
  padding:8px 14px;
  border-radius:10px;
  border:1px solid rgba(96,165,250,.5);
  background:rgba(30,41,59,.55);
  color:#bfdbfe;
  font-size:14px;
  font-weight:600;
  cursor:pointer;
  transition:.2s;
  backdrop-filter: blur(6px);
}

/* hover íš¨ê³¼ */
.back-btn:hover{
  background:#3b82f6;
  color:white;
  border-color:#60a5fa;
  box-shadow:0 0 12px rgba(96,165,250,.8);
  transform:translateY(-50%) scale(1.05);
}

/* í´ë¦­ */
.back-btn.active{
  background:#3b82f6;
  color:white;
  border-color:#60a5fa;
  box-shadow:0 0 12px rgba(96,165,250,.9);
    transform:translateY(-50%) scale(.96);
}

/* ===== ì™¼ìª½ ì„¤ëª… ì˜ì—­ ===== */
.side-info{
  position:fixed;
  top:110px;
  left:20px;
  width:320px;
  z-index:900;

  transition:transform .35s cubic-bezier(.25,.8,.25,1);
}

/* HUD íŒ¨ë„ */
.info-box{
  background:linear-gradient(
    180deg,
    rgba(15,23,42,.65),
    rgba(2,6,23,.75)
  );
  border-radius:18px;
  padding:18px 18px 16px;

  backdrop-filter:blur(12px);
  -webkit-backdrop-filter:blur(12px);

  /* í•µì‹¬: í…Œë‘ë¦¬ ëŒ€ì‹  ê´‘ì› */
  box-shadow:
    inset 0 0 0 1px rgba(96,165,250,.18),
    0 0 25px rgba(37,99,235,.25),
    0 10px 40px rgba(0,0,0,.9);
}

/* ì œëª© */
.info-title{
  font-size:15px;
  font-weight:700;
  letter-spacing:.5px;
  color:#93c5fd;
  margin-bottom:12px;
  padding-bottom:8px;
  border-bottom:1px solid rgba(96,165,250,.25);
}

.info-sub{
  font-size:10px;
  letter-spacing:2px;
  color:#60a5fa;
  opacity:.6;
  margin-bottom:4px;
}

/* ëª©ë¡ */
.guide-list{
  list-style:none;
  padding:0;
  margin:0;
}

.guide-list li{
  position:relative;
  padding-left:14px;
}

.guide-list li::before{
  content:"";
  position:absolute;
  left:0;
  top:9px;
  width:5px;
  height:5px;
  border-radius:50%;
  background:#8fb7ff;
  box-shadow:0 0 8px rgba(120,170,255,.8);
}

/* hover ì‹œ ì‚´ì§ ë°˜ì‘ (ê²Œì„ UI ëŠë‚Œ) */
.guide-list li:hover{
  color:#e5edff;
  transform:translateX(4px);
  transition:.15s;
}

/* ===== ì¶”ì²œì˜µì…˜ ë°•ìŠ¤ 2ë¶„í•  ===== */
.stats-summary{
  display:flex;
  gap:20px;
  padding:14px;
  background:#0a0a0a;
  border:1px solid #555;
  border-radius:8px;
}

/* ì™¼ìª½ ê²€ìƒ‰ ì˜ì—­ */
.summary-left{
  width:45%;
  min-width:240px;
  border-right:1px solid #333;
  padding-right:15px;
}

/* ì˜¤ë¥¸ìª½ ì¶”ì²œ í…ìŠ¤íŠ¸ */
.summary-right{
  width:55%;
  line-height:1.6;
  font-size:14px;

  /* â­ ì¶”ê°€ (í•µì‹¬) */
  word-break:break-word;
  overflow-wrap:anywhere;
}

/* ê²€ìƒ‰ì°½ */
.search-input{
  width:100%;
  padding:9px 11px;
  border-radius:7px;
  border:1px solid #374151;
  background:#020617;
  color:#e5e7eb;
  outline:none;
  margin-top:6px;
  box-sizing:border-box;
}

.search-input:focus{
  border-color:#60a5fa;
  box-shadow:0 0 8px rgba(96,165,250,.6);
}

/* ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ */
.search-result{
  margin-top:8px;
  max-height:240px;
  overflow-y:auto;
  border:1px solid #374151;
  border-radius:8px;
  background:#020617;
  box-shadow:0 10px 25px rgba(0,0,0,.6);
}

.search-item:last-child{ border-bottom:none; }

.search-item:hover{
  background:#1e293b;
  color:#93c5fd;
}

.weapon-guide{
  margin-top:12px;
  padding:10px;
  border-radius:8px;
  background:rgba(30,41,59,.45);
  border:1px solid rgba(96,165,250,.25);
  line-height:1.6;
  font-size:13px;
}
.weapon-guide b{ 
  color:#93c5fd; 
  }

/* ê²€ìƒ‰ ê²°ê³¼ ë“±ê¸‰ í‘œì‹œ */

/* 6ì„± */
.search-item.grade6{
  color:#ff6b6b;
  font-weight:700;
  text-shadow:0 0 6px rgba(255,70,70,.55);
}

/* 5ì„± */
.search-item.grade5{
  color:#ffd84d;
  font-weight:600;
  text-shadow:0 0 6px rgba(255,215,0,.45);
}

/* ë³„í‘œ í…ìŠ¤íŠ¸ */

.search-item.grade6:hover{
  background:rgba(255,60,60,.15);
}

.search-item.grade5:hover{
  background:rgba(255,215,0,.12);
}

/* ===== ê²€ìƒ‰ì°½ íšë“ í‘œì‹œ ===== */

/* íšë“ ë¬´ê¸° */
.search-item.owned{
  background:rgba(34,197,94,.10);
  box-shadow: inset 0 0 0 1px rgba(34,197,94,.25);
}

/* hover */
.search-item.owned:hover{
  background:rgba(34,197,94,.18);
}

.weapon-count{
  margin-left:10px;
  font-weight:700;
  color:#93c5fd;
  text-shadow:0 0 8px rgba(96,165,250,.6);
}

/* í•œ ì¤„ ì •ë ¬ */
.search-item{
  padding:8px 10px;
  cursor:pointer;
  border-bottom:1px solid rgba(255,255,255,.05);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

/* ì´ë¦„ */
.search-name{
  flex:1;
}

/* ì˜¤ë¥¸ìª½ ìƒíƒœ ë¬¶ìŒ */
.search-status{
  display:flex;
  align-items:center;
  gap:6px;
}

/* íšë“ í‘œì‹œ */
.search-owned-badge{
  background:#22c55e;
  color:#052e16;
  padding:2px 7px;
  border-radius:6px;
  font-size:11px;
  font-weight:700;
  box-shadow:0 0 6px rgba(0,255,120,.5);
}

/* â˜…í‘œì‹œ */
.grade-tag{
  margin-left:6px;
  font-size:12px;
  opacity:.9;
}

.search-item{
  cursor: pointer;
}

.search-item:hover{
  cursor: context-menu;
}

/* ì„ íƒëœ ë¬´ê¸° ì´ë¦„ í‘œì‹œ */
.card-title.target{
  color:#60a5fa !important;          /* ê¸€ì íŒŒë‘ */
  font-weight:800;
  text-shadow:0 0 10px rgba(96,165,250,.9);
}

/* ì ‘ê¸° ë²„íŠ¼ */
.side-toggle{
  position:absolute;
  right:-5px;
  top:18px;

  width:28px;
  height:28px;
  border-radius:8px;
  cursor:pointer;

  display:flex;
  align-items:center;
  justify-content:center;

  font-size:16px;
  font-weight:bold;

  background:rgba(30,41,59,.9);
  border:1px solid rgba(96,165,250,.5);
  color:#93c5fd;

  box-shadow:0 0 12px rgba(59,130,246,.5);
  transition:.25s;
}

.side-toggle:hover{
  background:#3b82f6;
  color:white;
}

/* ì ‘íŒ ìƒíƒœ : í™”ë©´ ë°–ìœ¼ë¡œ ì´ë™ */
.side-info.collapsed{
  transform:translateX(-315px);
}

/* ë‚´ìš© ìˆ¨ê¹€ */
.side-info.collapsed .info-sub,
.side-info.collapsed .info-title,
.side-info.collapsed .guide-list{
  opacity:0;
  pointer-events:none;
  transform:translateX(-10px);
}

.info-box{
  position:relative;
  overflow:hidden;
  transition:.25s;
}


  </style>
</head>
<body>
  
<div class="top-header">
  
  <button class="back-btn" onclick="goPage('index')">ğŸ§® ê¸°ì§ˆ íŒŒë°</button>
  <button class="back-btn" onclick="goPage('daily')">ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸</button>
</div>
<div class="side-info">
  <div class="info-box">
    <div class="side-toggle" id="sideToggle">â®</div>
    <div class="info-sub">SYSTEM</div>
<div class="info-title">íŒŒë° ì•ˆë‚´</div>
      <ul class="guide-list">
  <li>ì²´í¬ë¦¬ìŠ¤íŠ¸ ë¥¼ ëˆŒëŸ¬ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ì´ë™ ê°€ëŠ¥ </li>
  <li>ë°ì´í„°ëŠ” ë¸Œë¼ìš°ì €ì— ìë™ ì €ì¥</li>
  <li>Saveë¡œ ì €ì¥ëœ ë°ì´í„°ë¥¼ Loadë¡œ ë¶ˆëŸ¬ì˜¤ê¸° ê°€ëŠ¥</li>
  <li>ë¬´ê¸° ë„ê°ì—ì„œ ì „ì²´ì ì¸ íŒŒë° ìƒí™©ì„ í•œëˆˆì— ë³¼ìˆ˜ ìˆìŒ</li>
  <li>ê²€ìƒ‰ ì´ˆê¸°í™” ë²„íŠ¼ì„ ëˆŒëŸ¬ ì˜µì…˜ ë° ê²€ìƒ‰ ì´ˆê¸°í™”</li>
  <li>ë¬´ê¸° ê²€ìƒ‰í›„ ì¶”ì²œ ì„ íƒì§€ ìë™ ì„ íƒ</li>
  <li>ì¶”ì²œ ìŠ¤íƒ¯ì´ 2ê°œ ì´í•˜ë¼ë©´ í•´ë‹¹ ì„ íƒì§€ + (ì•„ë¬´ì˜µì…˜)
    4ê°œ ì´ìƒì´ë¼ë©´ ê·¸ì¤‘ 3ê°œ ì„ íƒ
  </li>
  <li>ê²€ìƒ‰í•œ ë¬´ê¸°ëŠ” ê²°ê³¼ì°½ì— íŒŒë€ìƒ‰ì¸ ì´ë¦„ìœ¼ë¡œ í™•ì¸ ê°€ëŠ¥</li>
  <li>ìµœë‹¤ ê¸°ì§ˆ ì €ê²© ì˜µì…˜ ì—ì„œ ì§€ì—­ì— ë”°ë¥¸ ìµœê³ íš¨ìœ¨ íŒŒë°</li>
  <li>ê²€ìƒ‰ ëª©ë¡ì—ì„œë„ ìš°í´ë¦­ìœ¼ë¡œ íšë“ ì²´í¬ ê°€ëŠ¥</li>
  
</ul>
  </div>
</div>
<div class="container">

  <div class="panel">
    <div class="panel-header">
    <div class="panel-title">â— ê¸°ì´ˆ ì˜µì…˜</div>
     <div class="toggle-wrapper">
      <button class="data-btn" onclick="exportToJSON()">ğŸ“¥ Save</button>
  <input type="file" id="importFile" style="display:none;" onchange="importFromJSON(event)" accept=".json">
  <button class="data-btn" onclick="document.getElementById('importFile').click()">ğŸ“¤ Load</button>
  <button class="data-btn" onclick="goPage('inventory')">ğŸ“š ë¬´ê¸° ë„ê°</button>
  <button class="data-btn" onclick="clearAll()">ğŸ”ƒ ê²€ìƒ‰ ì´ˆê¸°í™”</button>
 
  
</div>
    
  </div>
    <div class="options" id="primary"></div>
  </div>

  <div class="panel">
    <div class="panel-title">â— ì¶”ê°€ ì˜µì…˜</div>
    <div class="options" id="secondary"></div>
  </div>

  <div class="panel">
    <div class="panel-title">â— ìŠ¤í‚¬ ì˜µì…˜</div>
    <div class="options" id="skill"></div>
  </div>
  <div class="panel">
    <div class="panel-title">â— ì§€ì—­</div>
    <div class="options" id="area"></div>
  </div>
  <div class="panel">
  <div class="panel-title" id="weaponPanelTitle">â— ë¬´ê¸°</div>

  <!-- ìƒë‹¨ ì •ë³´ + ê²€ìƒ‰ 2ë¶„í•  -->
  <div id="stats-summary" class="stats-summary">

    <!-- ì™¼ìª½ : ê²€ìƒ‰ -->
    <div class="summary-left">
      <div class="search-title">ğŸ” ë¬´ê¸° ê²€ìƒ‰</div>

      <input
        type="text"
        id="weaponSearch"
        class="search-input"
        placeholder="ë¬´ê¸° ì´ë¦„ ì…ë ¥..."
        oninput="searchWeapon()"
      >
      <div id="weaponGuide" class="weapon-guide"></div>

      <div id="searchResult" class="search-result"></div>
    </div>

    <!-- ì˜¤ë¥¸ìª½ : ì¶”ì²œ ì •ë³´ -->
    <div class="summary-right" id="summaryText">
    </div>

  </div>

  <!-- ë¬´ê¸° ê²°ê³¼ ì¹´ë“œ ì¶œë ¥ ì˜ì—­ (â˜… ì´ê±° ë°˜ë“œì‹œ í•„ìš”) -->
  <div id="result" class="result-list"></div>

</div>

<script>

let autoSelecting = false;
let lockedTargetWeapon = null;
let dbdata = [];
let optiondata = {};
let currentResult = [];
let primaryStrings = [];
let subStrings = [];
let excludedIds = new Set(JSON.parse(localStorage.getItem("excludedCards") || "[]"));
let viewMode = "normal";

const selected = {
  primary: [],
  secondary: null,
  skill: null,
  area: null
};

function parseOptions(field){
  if(!field) return [];

  return field
    .toString()
    .split(/[,/|]/)
    .map(v=>normalizeText(v))
    .filter(v=>v.length>0);
}

function goPage(page){

  // GAS ì›¹ì•±ì¸ì§€ í™•ì¸
  if (location.hostname.includes("script.google.com")) {

    // í˜„ì¬ URL ìœ ì§€í•˜ë©´ì„œ page íŒŒë¼ë¯¸í„°ë§Œ êµì²´
    const url = new URL(window.location.href);
    url.searchParams.set('page', page);
    window.location.replace(url.toString());

  } else {

    // GitHub Pages (ì •ì  html ì´ë™)
    window.location.href = page + ".html";

  }
}

async function loadData() {
  try {
    const res = await fetch("https://kuu6132.github.io/db.json");
    const data = await res.json();

    dbdata = data.db;
    optiondata = data.options;
    
    init();
    updateWeaponPanelTitle();

    setTimeout(updateResult, 0);

  } catch (err) {
    console.error("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", err);
  }
}

loadData();

function init() {
  createButtons("primary", optiondata.primary, true);
  createButtons("secondary", optiondata.secondary, true);
  createButtons("skill", optiondata.skill, true);
  createButtons("area", optiondata.area, true);

}

function createButtons(type, list, single) {
    
  const wrap = document.getElementById(type);
  wrap.innerHTML = "";
  // ì˜µì…˜ ë²„íŠ¼ë“¤
  list.forEach(value => {
    const btn = document.createElement("div");
    btn.className = "btn";
    btn.textContent = value;
    btn.onclick = () => toggle(type, value, btn );
    wrap.appendChild(btn);
  });
}

function isActive(value, selected) {
  return value && value === selected ? 'style="background:#f1dc55;color:#000;border-color:#f1dc55"' : '';
}

function updateResult() {

  const best = getBestFarmingArea();
  const remainweapon = getRemainingWeapons(); // â† ë§¤ë²ˆ ìƒˆë¡œ ê³„ì‚°
  const total = dbdata.length;
  const cleared = total - remainweapon.length;

 let percent = 0;
 if (total > 0) {
  percent = Math.floor(cleared / total * 100);
 }
  const resultEl = document.getElementById("result");
  resultEl.innerHTML = "";
  const statsEl = document.getElementById("summaryText")
  const selectedAreaText = selected.area ? selected.area : "ì—†ìŒ";

  statsEl.innerHTML = `
  <div class="summary-block">
  <div class="summary-title">â€¼ï¸ ìµœë‹¤ ê¸°ì§ˆ ì €ê²© ì˜µì…˜ â€¼ï¸</div>

    <div>ì„ íƒí•œ ì§€ì—­: <b>${selectedAreaText}</b></div>
  <div>ìŠ¤íƒ¯ ì˜µì…˜: <b>${'ì—†ìŒ'}</b></div>
  <div>ìŠ¤í‚¬ ì˜µì…˜: <b>${'ì—†ìŒ'}</b></div>

  <hr class="summary-divider">

  <div class="summary-recommend">
    ì¶”ì²œ íŒŒë°ì§€ì—­:
    <b>${best ? best.area + " (ë‚˜ì˜¤ëŠ” ë¬´ê¸° " + best.count + "ê°œ)" : "ì—†ìŒ"}</b>
  </div>
</div>
`;
  // 1. ì„ íƒ ì—¬ë¶€ í™•ì¸
  const hasPrimary = selected.primary && selected.primary.length > 0;
  const isAnySelected = hasPrimary || !!selected.secondary || !!selected.skill || !!selected.area;

  let result = [];
  
   {
    // =========================
    // ğŸ¯ viewMode = normal
    // =========================
    if (!isAnySelected) {
            resultEl.innerHTML = `<div class="hint" >ğŸ” ê¸°ì´ˆ ì˜µì…˜ì´ë‚˜ ì§€ì—­ì„ ì„ íƒí•˜ë©´ ë¬´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
      return;
    } else {
      result = dbdata.filter(row => {
        // ğŸ”¥ excluded ìˆ¨ê¹€
        

        const rowOpts = [
        ...parseOptions(row["ì˜µì…˜1"]),
        ...parseOptions(row["ì˜µì…˜2"]),
        ...parseOptions(row["ì˜µì…˜3"])
        ];

        // A. Primary ê²€ì‚¬: ì„ íƒëœ ê¸°ì´ˆ ì˜µì…˜ ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ í†µê³¼ (OR)
        const passPrimary = !hasPrimary || selected.primary.some(sel => rowOpts.includes(sel.trim()));

        // B. ë‚˜ë¨¸ì§€ ê²€ì‚¬: Secondary, Skill, AreaëŠ” ì„ íƒëœ ê²½ìš° ëª¨ë‘ ë§Œì¡±í•´ì•¼ í•¨ (AND)
        const otherCategories = {
          secondary: selected.secondary,
          skill: selected.skill,
          area: selected.area
        };

        const passOthers = Object.entries(otherCategories).every(([type, sel]) => {
          if (!sel) return true; // ì„ íƒ ì•ˆ í–ˆìœ¼ë©´ í†µê³¼
          if (type === "area") return row["ì§€ì—­"] && row["ì§€ì—­"].includes(sel);
          return rowOpts.includes(sel.trim());
        });

        // ê¸°ì´ˆ ì˜µì…˜ ì¡°ê±´ê³¼ ê¸°íƒ€ ì¡°ê±´ì´ ëª¨ë‘ ë§ì•„ì•¼ ìµœì¢… í‘œì‹œ
        return passPrimary && passOthers;
      });
      // ==========================================
  // ğŸ“Š 1. í†µê³„ ê³„ì‚° ë¡œì§ ì¶”ê°€
  // ==========================================
  const countPrimary = {};
  const countSub = {};
 // 1. í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ê¸° (ì œì™¸ìš©)
  const mySelected = new Set();
  
  // Primaryê°€ ë°°ì—´ì¸ ê²½ìš° (ë‹¤ì¤‘ ì„ íƒ)
  if (Array.isArray(selected.primary)) {
    selected.primary.forEach(v => mySelected.add(v.trim()));
  }
  // Secondary, Skill ë“±ì´ ë‹¨ì¼ ë¬¸ìì—´ì¸ ê²½ìš°
  ["secondary", "skill"].forEach(type => {
    if (selected[type]) mySelected.add(selected[type].trim());
  });
  result.forEach(row => {
    // ì˜µì…˜1 í†µê³„
    parseOptions(row["ì˜µì…˜1"]).forEach(opt=>{
  countPrimary[opt] = (countPrimary[opt] || 0) + 1;
 });
    
    // ì˜µì…˜2, ì˜µì…˜3 í†µí•© í†µê³„ (ì¤‘ë³µ ë‹¨ì–´ 1ê°œ ì¶”ì¶œìš©)
    [...parseOptions(row["ì˜µì…˜2"]), ...parseOptions(row["ì˜µì…˜3"])]
  .forEach(opt=>{
    if(!mySelected.has(opt)){
      countSub[opt] = (countSub[opt] || 0) + 1;
    }
  });
  });

  // ë¹ˆë„ìˆ˜ ë†’ì€ ìˆœ ì •ë ¬ (ê°’ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ)
  const sortedPrimary = Object.entries(countPrimary)
  .sort((a, b) => b[1] - a[1]);

 let topPrimary = [];

 if(sortedPrimary.length){

  // 3ìœ„ ì ìˆ˜(ì»·ë¼ì¸)
  const cutoffIndex = Math.min(2, sortedPrimary.length - 1);
  const cutoffScore = sortedPrimary[cutoffIndex][1];

  // ì»·ë¼ì¸ ì´ìƒ ì „ë¶€ í¬í•¨
  topPrimary = sortedPrimary.filter(e => e[1] >= cutoffScore);
 }

  const sortedSub = Object.entries(countSub)
  .sort((a, b) => b[1] - a[1]);

 const maxSubCount = sortedSub.length ? sortedSub[0][1] : 0;
  // ìµœê³ ê°’ê³¼ ê°™ì€ ì• ë“¤ ì „ë¶€ ì„ íƒ
 const topSub = sortedSub.filter(e => e[1] === maxSubCount);
 const topSubSet = new Set(topSub.map(e=>e[0]));
 Object.keys(countPrimary).forEach(k=>delete countPrimary[k]);

 result.forEach(row=>{

  const hasTopSub =
    parseOptions(row["ì˜µì…˜2"]).some(opt=>topSubSet.has(opt)) ||
    parseOptions(row["ì˜µì…˜3"]).some(opt=>topSubSet.has(opt));

  if(!hasTopSub) return;

  // ì—¬ê¸°ë¶€í„° ì˜µì…˜1 ì¹´ìš´íŠ¸
  parseOptions(row["ì˜µì…˜1"]).forEach(opt=>{
    countPrimary[opt] = (countPrimary[opt]||0)+1;
  });

 });
 primaryStrings = topPrimary.map(e => `${e[0]}(${e[1]})`);
 subStrings = topSub.map(e => `${e[0]}(${e[1]})`);
  const statsEl = document.getElementById("summaryText");
 let optionText = "ì—†ìŒ";
 let topText = "ì—†ìŒ";

 if(selected.area){
  const rec = getAreaOptionRecommendation(selected.area);

  if(rec){
    optionText = rec.top3
  .map(opt => `${opt}(${rec.top3Count[opt]||0})`)
  .join(', ');

  topText = `${rec.bestOption} (${rec.score}ê°œ)`;
  }
 }
  const selectedAreaText = selected.area ? selected.area : "ì—†ìŒ";

  statsEl.innerHTML = `
<div class="summary-block">
  <div class="summary-title">â€¼ï¸ ìµœë‹¤ ê¸°ì§ˆ ì €ê²© ì˜µì…˜ â€¼ï¸</div>

  <div>ì„ íƒí•œ ì§€ì—­: <b>${selectedAreaText}</b></div>
  <div>ìŠ¤íƒ¯ ì˜µì…˜: <b>${optionText}</b></div>
  <div>ìŠ¤í‚¬ ì˜µì…˜: <b>${topText}</b></div>

  <hr class="summary-divider">

  <div class="summary-recommend">
    ì¶”ì²œ íŒŒë°ì§€ì—­:
    <b>${best ? best.area + " (ë‚˜ì˜¤ëŠ” ë¬´ê¸° " + best.count + "ê°œ)" : "ì—†ìŒ"}</b>
  </div>
</div>
`;
 result.sort((a,b)=>{

  const aOwned = excludedIds.has(a["ì´ë¦„"]);
  const bOwned = excludedIds.has(b["ì´ë¦„"]);

  // 1ï¸âƒ£ ë¯¸íšë“ ë¨¼ì €
  if(aOwned !== bOwned){
    return aOwned ? 1 : -1;
  }

  // 2ï¸âƒ£ ì„±ê¸‰ ë†’ì€ ê²ƒ ë¨¼ì € (6ì„± â†’ 5ì„±)
  const gradeA = parseInt(a["ì„±ê¸‰"]);
  const gradeB = parseInt(b["ì„±ê¸‰"]);

  if(gradeA !== gradeB){
    return gradeB - gradeA;
  }

  // 3ï¸âƒ£ ì´ë¦„ìˆœ
  return a["ì´ë¦„"].localeCompare(b["ì´ë¦„"], 'ko');
  });
    }
  }
  
  result.forEach(row => {
    const card = document.createElement("div");
    const grade = row["ì„±ê¸‰"];
    const id = row["ì´ë¦„"];

    card.className = "result-card grade-" + grade.replace("ì„±", "");
    card.dataset.id = id;

    if (excludedIds.has(id)) {
      card.classList.add("excluded");
    }

    // ìš°í´ë¦­ ì œì™¸ ë¡œì§
    card.addEventListener("contextmenu", function (e) {
      e.preventDefault();
      if (excludedIds.has(id)) {
        excludedIds.delete(id);
        card.classList.remove("excluded");
        updateResult();
        
      } else {
        excludedIds.add(id);
        card.classList.add("excluded");
      }
      localStorage.setItem("excludedCards", JSON.stringify([...excludedIds]));
      
        card.remove();
        renderStats();
        updateResult();
        refreshSearchList();
        updateWeaponPanelTitle();   
    });

    const baseUrl = "https://cdn.jsdelivr.net/gh/kuu6132/end-field@main/%EB%AC%B4%EA%B8%B0/";
    const imageUrl = row["ì´ë¦„"]
      ? baseUrl + encodeURIComponent(row["ì´ë¦„"])
      : "https://via.placeholder.com/300x375?text=No+Image";

    card.innerHTML = `
      <div class="card-image"><img src="${imageUrl}.png"></div>
      <div class="card-header">
        <div class="card-title">${row["ì´ë¦„"]}</div>
        <div class="card-grade">${row["ì„±ê¸‰"]}</div>
      </div>
      <div class="card-options">
        <span class="option-tag ${isSelected(row["ì˜µì…˜1"]) ? "selected" : ""}">
          ${row["ì˜µì…˜1"] ?? ""}
        </span>
        <span class="option-tag ${isSelected(row["ì˜µì…˜2"]) ? "selected" : ""}">
          ${row["ì˜µì…˜2"] ?? ""}
        </span>
        <span class="option-tag ${isSelected(row["ì˜µì…˜3"]) ? "selected" : ""}">
          ${row["ì˜µì…˜3"] ?? ""}
        </span>
      </div>
      <div class="card-desc">${row["ì§€ì—­"] ?? ""}</div>
    `;

    resultEl.appendChild(card);
  });
  currentResult = result; // resultëŠ” ì„ íƒí•´ì„œ ë‚˜ì˜¨ ê²°ê³¼ê°’
  if(!autoSelecting){
  updateOptionAvailability();
  }
  updateWeaponPanelTitle();
  if(lockedTargetWeapon){
  setTimeout(()=>focusWeapon(lockedTargetWeapon), 0);
  }
}

function isSelected(optionValue) {
    if (!optionValue) return false;
    const val = optionValue.trim();
    return (
      (selected.primary && selected.primary.includes(val)) || // ë°°ì—´ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
      val === selected.secondary ||
      val === selected.skill ||
      (selected.area && val === selected.area.trim())
    );
}

function calculateAreaScore(areaName){

  const remaining = getRemainingWeapons(); // íŒŒë° ì•ˆí•œ ë¬´ê¸°
  const target = normalizeText(areaName);

  /* 1ï¸âƒ£ í•´ë‹¹ ì§€ì—­ ë¬´ê¸°ë§Œ ì¶”ì¶œ */
  const areaWeapons = remaining.filter(row=>{
    if(!row["ì§€ì—­"]) return false;

    const areas = String(row["ì§€ì—­"])
      .replace(/\u00A0/g,' ')
      .split(',')
      .map(a=>normalizeText(a));

    return areas.includes(target);
  });

  if(areaWeapons.length === 0) return 0;


  /* 2ï¸âƒ£ ì§€ì—­ ë‚´ë¶€ì—ì„œ ì˜µì…˜2+3 ìµœë‹¤ì˜µì…˜ ì°¾ê¸° */
  const subCount = {};

  areaWeapons.forEach(row=>{
    [...parseOptions(row["ì˜µì…˜2"]), ...parseOptions(row["ì˜µì…˜3"])]
      .forEach(opt=>{
        subCount[opt] = (subCount[opt] || 0) + 1;
      });
  });

  const sortedSub = Object.entries(subCount)
    .sort((a,b)=>b[1]-a[1]);

  if(!sortedSub.length) return 0;

  const topSub = sortedSub[0][0];


  /* 3ï¸âƒ£ ê·¸ ìµœë‹¤ì˜µì…˜ì„ ê°€ì§„ ë¬´ê¸°ë§Œ ë‚¨ê¹€ */
  const filteredWeapons = areaWeapons.filter(row=>
    parseOptions(row["ì˜µì…˜2"]).includes(topSub) ||
    parseOptions(row["ì˜µì…˜3"]).includes(topSub)
  );


  /* 4ï¸âƒ£ ê·¸ ë¬´ê¸°ë“¤ ê¸°ì¤€ ì˜µì…˜1 TOP3 ê³„ì‚° */
  const primaryCount = {};

  filteredWeapons.forEach(row=>{
    parseOptions(row["ì˜µì…˜1"]).forEach(opt=>{
      primaryCount[opt] = (primaryCount[opt] || 0) + 1;
    });
  });

  const topPrimary = Object.entries(primaryCount)
    .sort((a,b)=>b[1]-a[1])
    .slice(0,3)
    .map(e=>e[0]);

  const topPrimarySet = new Set(topPrimary);


  /* 5ï¸âƒ£ TOP3 ì˜µì…˜ì„ ê°€ì§„ ë¬´ê¸° ê°œìˆ˜ */
  let score = 0;

  filteredWeapons.forEach(row=>{
    const hasPrimary =
      parseOptions(row["ì˜µì…˜1"])
        .some(opt => topPrimarySet.has(opt));

    if(hasPrimary) score++;
  });

  return score;
}

function normalizeAreaName(name){
  if(!name) return "";

  name = normalizeText(name);

  // ëª¨ë“  ê³µë°± ì œê±° í›„ ë¹„êµ
  const key = name.replace(/\s/g,'');

  if(key.includes("ê±°ì ")) return "ê±°ì  ì§€ì—­";
  if(key.includes("ì—°êµ¬")) return "ì˜¤ë¦¬ì§€ëŠ„ ì—°êµ¬ êµ¬ì—­";
  if(key.includes("ê´‘ë§¥")) return "ê´‘ë§¥ êµ¬ì—­";
  if(key.includes("ì—ë„ˆì§€")) return "ì—ë„ˆì§€ ê³µê¸‰ ê³ ì§€";
  if(key.includes("ë¬´ë¦‰")) return "ë¬´ë¦‰ì„±";

  return name;
}

function getBestFarmingArea(){

  const areas = [
    "ê±°ì  ì§€ì—­",
    "ì˜¤ë¦¬ì§€ëŠ„ ì—°êµ¬ êµ¬ì—­",
    "ê´‘ë§¥ êµ¬ì—­",
    "ì—ë„ˆì§€ ê³µê¸‰ ê³ ì§€",
    "ë¬´ë¦‰ì„±"
  ];

  let bestArea = null;
  let bestScore = 0;

  areas.forEach(area=>{
    const score = calculateAreaScore(area);

    if(score > bestScore){
      bestArea = area;
      bestScore = score;
    }
  });

  return bestArea ? {area:bestArea, count:bestScore} : null;
}

function getAreaOptionRecommendation(areaName){

  const remaining = getRemainingWeapons();
  const target = normalizeText(areaName);

  // 1ï¸âƒ£ ì§€ì—­ ë¬´ê¸°ë§Œ
  const areaWeapons = remaining.filter(row=>{
    if(!row["ì§€ì—­"]) return false;

    const areas = String(row["ì§€ì—­"])
      .split(',')
      .map(a=>normalizeText(a));

    return areas.includes(target);
  });

  if(areaWeapons.length === 0) return null;

  /* ---------------------------------
     2ï¸âƒ£ ì˜µì…˜2+3 í†µí•© ë¹ˆë„ ê³„ì‚°
  --------------------------------- */

  const subCount = {};

  areaWeapons.forEach(row=>{
    [...parseOptions(row["ì˜µì…˜2"]), ...parseOptions(row["ì˜µì…˜3"])]
      .forEach(opt=>{
        subCount[opt] = (subCount[opt]||0)+1;
      });
  });

  // ìµœë‹¤ ë“±ì¥ íšŸìˆ˜
  const maxCount = Math.max(...Object.values(subCount));

  // ë™ë¥  í›„ë³´ë“¤
  const candidates = Object.entries(subCount)
    .filter(([opt,count])=>count===maxCount)
    .map(e=>e[0]);

  /* ---------------------------------
     3ï¸âƒ£ í›„ë³´ë³„ ì‹¤ì œ íŒŒë° íš¨ìœ¨ ê³„ì‚°
  --------------------------------- */

  let bestOption = null;
  let bestScore = -1;
  let bestTop3 = [];
  let bestTop3Count = {};

  candidates.forEach(option=>{

    // ì´ ì˜µì…˜ ê°€ì§„ ë¬´ê¸°ë§Œ
    const optionWeapons = areaWeapons.filter(row=>
      parseOptions(row["ì˜µì…˜2"]).includes(option) ||
      parseOptions(row["ì˜µì…˜3"]).includes(option)
    );

    // ì˜µì…˜1 ì¹´ìš´íŠ¸
    const primaryCount = {};

    optionWeapons.forEach(row=>{
      parseOptions(row["ì˜µì…˜1"]).forEach(opt=>{
        primaryCount[opt]=(primaryCount[opt]||0)+1;
      });
    });

    // ì˜µì…˜1 TOP3
    const top3 = Object.entries(primaryCount)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,3)
      .map(e=>e[0]);

    const top3Set = new Set(top3);

    // ì‹¤ì œ íŒŒë° íš¨ìœ¨ (í•µì‹¬)
    let score = 0;
    const top3HitCount = {};

  optionWeapons.forEach(row=>{

  const opt1List = parseOptions(row["ì˜µì…˜1"]);

  const hasTop3 =
    opt1List.some(opt=>top3Set.has(opt));

  if(hasTop3){

    score++;

    // â­ ì–´ë–¤ ì˜µì…˜1ì´ ì‹¤ì œ ëª‡ ë²ˆ ë“±ì¥í–ˆëŠ”ì§€ ê¸°ë¡
    opt1List.forEach(opt=>{
      if(top3Set.has(opt)){
        top3HitCount[opt] = (top3HitCount[opt]||0)+1;
      }
    });

  }
  });

    // ìµœê³  ì„ íƒ
    if(score > bestScore){
  bestScore = score;
  bestOption = option;
  bestTop3 = top3;
  bestTop3Count = top3HitCount;
  }

  });

  return {
    bestOption,
    top3: bestTop3,
    top3Count: bestTop3Count,
  score: bestScore
  };
}

function getRemainingWeapons(){
  return dbdata.filter(row => !excludedIds.has(row["ì´ë¦„"]));
}

function renderStats() {
      const statsEl = document.getElementById("stats-container");
  if (!statsEl || !currentResult || currentResult.length === 0) {
    if (statsEl) statsEl.innerHTML = "";
    return;
  }

  const mySelected = new Set();

  if (Array.isArray(selected.primary)) {
    selected.primary.forEach(v => mySelected.add(v.trim()));
  }

  ["secondary", "skill", "area"].forEach(type => {
    if (selected[type] && typeof selected[type] === "string") {
      mySelected.add(selected[type].trim());
    }})
};

function normalizeText(str){
  if(!str) return "";

  return str
    .toString()
    // ëª¨ë“  íŠ¹ìˆ˜ ê³µë°± ì œê±°
    .replace(/[\u200B-\u200D\uFEFF]/g, '')  // zero width
    .replace(/\u00A0/g,' ')                 // NBSP
    .replace(/\u2007/g,' ')
    .replace(/\u202F/g,' ')
    // ì¼ë°˜ ê³µë°± ì •ë¦¬
    .replace(/\s+/g,' ')
    .trim();
}

function updateOptionAvailability() {

  const types = ["primary", "secondary", "skill", "area"];

  types.forEach(type => {
    document.querySelectorAll(`#${type} .btn`).forEach(btn => {
      const value = btn.textContent;

      const isSelected = type === "primary" 
        ? selected.primary.includes(value) 
        : selected[type] === value;

      if (isSelected) {
  btn.classList.remove("disabled");
  btn.classList.add("active"); // â˜… ì´ê±° ì¶”ê°€ (í•µì‹¬)
  return;
}

      const isPossible = dbdata.some(row => {
        if (excludedIds.has(row["ì´ë¦„"])) return false;

        return types.every(t => {
          let sel = (t === type) 
            ? (t === "primary" ? [...selected.primary, value] : value) 
            : selected[t];

          if (!sel || (Array.isArray(sel) && sel.length === 0)) return true;

          const rowOpts = [
            ...parseOptions(row["ì˜µì…˜1"]),
            ...parseOptions(row["ì˜µì…˜2"]),
            ...parseOptions(row["ì˜µì…˜3"])
          ];

          if (t === "area") {
            if(!row["ì§€ì—­"]) return false;
            return String(row["ì§€ì—­"])
              .split(',')
              .map(a=>normalizeText(a))
              .includes(normalizeText(sel));
          }

          if (Array.isArray(sel)) {
            return sel.some(s => rowOpts.includes(s.trim()));
          }

          return rowOpts.includes(sel.trim());
        });
      });

      btn.classList.toggle("disabled", !isPossible);
    });
  });
}

function clearType(type) {
  if (type === "primary") {
    selected[type] = [];
  } else {
    selected[type] = null;  
    }
  document.querySelectorAll(`#${type} .btn`)
    .forEach(b => b.classList.remove("active"));
}

const types = ["primary", "secondary", "skill","area"];

function clearAll() {

  lockedTargetWeapon = null;

  // 1. ì„ íƒê°’ ì´ˆê¸°í™” + ë²„íŠ¼ active ì œê±°
  types.forEach(t => clearType(t));

  // â­â­â­ ê²€ìƒ‰ì°½ ì´ˆê¸°í™” ì¶”ê°€
  const input = document.getElementById("weaponSearch");
  if(input){
    input.value = "";
  }

  // ìë™ì™„ì„± ëª©ë¡ ì œê±°
  const resultBox = document.getElementById("searchResult");
  if(resultBox){
    resultBox.innerHTML = "";
  }

  // ì¶”ì²œ ì•ˆë‚´ ì œê±°
  const guide = document.getElementById("weaponGuide");
  if(guide){
    guide.innerHTML = "";
  }

  // 2. ê²°ê³¼ ëª©ë¡ ë‹¤ì‹œ í‘œì‹œ
  updateResult();

  // 3. ë²„íŠ¼ ìƒíƒœ ë³µêµ¬
  updateOptionAvailability();
}

function toggle(type, value, btn) {
  
  if (type === "primary") {

    const index = selected.primary.indexOf(value);

    if (index > -1) {
      selected.primary.splice(index, 1);
      btn.classList.remove("active");
    } else {
      selected.primary.push(value);
      btn.classList.add("active");
    }

  } else {

    if (selected[type] === value) {
      selected[type] = null;
      btn.classList.remove("active");
    } else {
      selected[type] = value;
      document.querySelectorAll(`#${type} .btn`)
        .forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
    }

  }

  // â­â­â­ í•µì‹¬
  // ìë™ì„ íƒ ì¤‘ì—ëŠ” ê²°ê³¼ ì¬ê³„ì‚° ê¸ˆì§€
  if(!autoSelecting){
    updateResult();
    updateOptionAvailability();
  }
}

function exportToJSON() {

  const saveData = {
    excludedCards: JSON.parse(localStorage.getItem("excludedCards") || "[]"),
    optionCounts: JSON.parse(localStorage.getItem("optionCounts") || "{}"),
    excludedGroups: JSON.parse(localStorage.getItem("excludedGroups") || "[]")
    
  };

  // ì•„ë¬´ ë°ì´í„°ë„ ì—†ìœ¼ë©´ ë°©ì§€
  if(
    saveData.excludedCards.length===0 &&
    Object.keys(saveData.optionCounts).length===0 &&
    saveData.dailyChecklist.length===0
  ){
    alert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  const blob = new Blob(
    [JSON.stringify(saveData, null, 2)],
    { type: "application/json" }
  );

  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `endfield_backup_${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();

  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function importFromJSON(event){
  const file = event.target.files[0];
  if(!file) return;

  const reader = new FileReader();

  reader.onload = function(e){
    try{
      const data = JSON.parse(e.target.result);

      if(data.excludedCards)
        localStorage.setItem("excludedCards", JSON.stringify(data.excludedCards));

      if(data.optionCounts)
        localStorage.setItem("optionCounts", JSON.stringify(data.optionCounts));

      if(data.excludedGroups)
        localStorage.setItem("excludedGroups", JSON.stringify(data.excludedGroups));

        alert("ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!");
      location.reload();

    }catch(err){
      alert("ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.");
    }
  };

  reader.readAsText(file);
}

window.addEventListener("scroll", () => {
  const header = document.querySelector(".top-header");

  if(window.scrollY > 10){
    header.classList.add("scrolled");
  }else{
    header.classList.remove("scrolled");
  }
});

function setActiveTab(){

  let currentPage = "index";

  // 1ï¸âƒ£ GAS : ?page=
  const params = new URLSearchParams(window.location.search);
  const paramPage = params.get("page");

  if(paramPage){
    currentPage = paramPage;
  }
  else{
    // 2ï¸âƒ£ GitHub Pages íŒŒì¼ëª… íŒë³„
    const href = location.href.toLowerCase();

    if(href.includes("daily")) currentPage = "daily";
    else  currentPage = "index";
  }

  // ë²„íŠ¼ active ì ìš©
  document.querySelectorAll(".back-btn").forEach(btn=>{
    btn.classList.remove("active");

    const onclick = btn.getAttribute("onclick");
    if(!onclick) return;

    if(onclick.includes(currentPage)){
      btn.classList.add("active");
    }
  });
}

function normalizeSearch(str){
  return normalizeText(str).replace(/\s/g,'').toLowerCase();
}

function searchWeapon(){

  const keyword = normalizeSearch(document.getElementById("weaponSearch").value);

// ê²€ìƒ‰ì–´ê°€ ì™„ì „íˆ ë¹„ë©´ ìƒíƒœ ì´ˆê¸°í™”
if(!keyword){
  resetSearchState();
  showUnownedList();
  return;
}
  const resultBox = document.getElementById("searchResult");

  resultBox.innerHTML="";
  if(!keyword) return showUnownedList();

  const remaining = dbdata;

 dbdata
  .filter(w=>{
    const nameKey = normalizeSearch(w["ì´ë¦„"]);
    return nameKey.includes(keyword);
  })
  .sort((a,b)=>searchSort(a,b,keyword))
  .forEach(w=>{
    addSearchItem(w["ì´ë¦„"]);
  });
}

function focusWeapon(name){

  // ì´ì „ ê°•ì¡° ì œê±°
  document.querySelectorAll(".card-title")
    .forEach(el => el.classList.remove("target"));

  // ì¹´ë“œ ì°¾ê¸°
  const card = document.querySelector(`.result-card[data-id="${name}"]`);
  if(!card) return;

  

  // ì´ë¦„ ê°•ì¡°
  const title = card.querySelector(".card-title");
  if(title){
    title.classList.add("target");
  }
}

function showUnownedList(){

  const resultBox = document.getElementById("searchResult");
  resultBox.innerHTML="";

  if(!dbdata || dbdata.length===0) return;

  // ğŸ”¥ ì „ì²´ ë¬´ê¸°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
  [...dbdata]
    .sort(weaponSort)
    .forEach(w=>{
      addSearchItem(w["ì´ë¦„"]);
    });
}

function addSearchItem(name){

  const weapon=dbdata.find(w=>w["ì´ë¦„"]===name);
  if(!weapon) return;

  const grade=String(weapon["ì„±ê¸‰"]);
  const is6=grade.includes("6");

  const div=document.createElement("div");
  div.className="search-item "+(is6?"grade6":"grade5");

  const isOwned = excludedIds.has(name);
  if(isOwned){
    div.classList.add("owned");
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì™¼ìª½ : ì´ë¦„ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const title=document.createElement("span");
  title.className="search-name";
  title.textContent=name;

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì˜¤ë¥¸ìª½ : ìƒíƒœ ë¬¶ìŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const statusWrap=document.createElement("span");
  statusWrap.className="search-status";

  // íšë“ ë°°ì§€
  if(isOwned){
    const badge=document.createElement("span");
    badge.className="search-owned-badge";
    badge.textContent="âœ” íšë“";
    statusWrap.appendChild(badge);
  }

  // â˜…ë“±ê¸‰
  const tag=document.createElement("span");
  tag.className="grade-tag";
  tag.textContent=is6?"(â˜…6)":"(â˜…5)";
  statusWrap.appendChild(tag);

  div.appendChild(title);
  div.appendChild(statusWrap);

  div.onclick = ()=>{

  // ì´ì „ ìƒíƒœ ì´ˆê¸°í™”
  resetSearchState();

  // ê²€ìƒ‰ì°½ í‘œì‹œ
  document.getElementById("weaponSearch").value = name;
  document.getElementById("searchResult").innerHTML = "";
  lockedTargetWeapon = name;

  // ì¶”ì²œ ê³„ì‚° (â­ í•œ ë²ˆë§Œ!)
  const rec = getTargetWeaponRecommendation(name);
  if(!rec) return;

  applyRecommendation(rec);

  // â­ ë§ˆì§€ë§‰ì— ë‹¨ 1ë²ˆë§Œ
  updateResult();
  updateOptionAvailability();

  // ì™¼ìª½ ì•ˆë‚´ í…ìŠ¤íŠ¸
  const guide=document.getElementById("weaponGuide");
  guide.innerHTML = `
    <b>ì¶”ì²œ ì§€ì—­:</b> ${rec.area} (${rec.score}ê°œ)<br>
    <b>ì¶”ì²œ ì˜µì…˜:</b> ${rec.option}<br>
    <b>ì¶”ì²œ ìŠ¤íƒ¯:</b> ${rec.stats.map(e=>`${e[0]}(${e[1]})`).join(", ")}
  `;

  // ì¹´ë“œë¡œ ìŠ¤í¬ë¡¤
  focusWeapon(name);
};

// ğŸ”¥ ê²€ìƒ‰ì°½ì—ì„œë„ ìš°í´ë¦­ íšë“ í† ê¸€
div.addEventListener("contextmenu", (e)=>{
  e.preventDefault();

  const isOwned = excludedIds.has(name);

  if(isOwned){
    excludedIds.delete(name);
  }else{
    excludedIds.add(name);
  }

  localStorage.setItem("excludedCards", JSON.stringify([...excludedIds]));

  refreshSearchList();
  updateResult();
  updateWeaponPanelTitle();

  // â­â­â­â­â­ ì—¬ê¸° ì¶”ê°€ (ê°€ì¥ ì¤‘ìš”)
  setTimeout(()=>{
    const input = document.getElementById("weaponSearch");
    if(input){
      const pos = input.selectionStart ?? input.value.length;
      input.focus();
      input.setSelectionRange(pos,pos);
    }
  },0);
});

  document.getElementById("searchResult").appendChild(div);
}

function refreshSearchList(){

  const input=document.getElementById("weaponSearch");
  if(!input) return;

  const keyword=normalizeSearch(input.value);

  // ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´ ìë™ì™„ì„± ë‹¤ì‹œ
  if(keyword){
    searchWeapon();
  }
  // ê²€ìƒ‰ì–´ ì—†ìœ¼ë©´ ì „ì²´ ëª©ë¡ ë‹¤ì‹œ
  else{
    showUnownedList();
  }
}

function weaponSort(a, b){

  const ownedA = excludedIds.has(a["ì´ë¦„"]);
  const ownedB = excludedIds.has(b["ì´ë¦„"]);

  /* 1ìˆœìœ„ : íšë“ ì—¬ë¶€ (ë¯¸íšë“ ë¨¼ì €) */
  if(ownedA !== ownedB){
    return ownedA ? 1 : -1;
  }

  /* 2ìˆœìœ„ : ì„±ê¸‰ (6ì„± ë¨¼ì €) */
  const gradeA = parseInt(a["ì„±ê¸‰"]);
  const gradeB = parseInt(b["ì„±ê¸‰"]);

  if(gradeA !== gradeB){
    return gradeB - gradeA;
  }

  /* 3ìˆœìœ„ : ì´ë¦„ìˆœ */
  return a["ì´ë¦„"].localeCompare(b["ì´ë¦„"], 'ko');
}

function updateWeaponPanelTitle(){

  if(!dbdata || dbdata.length===0) return;

  const remaining = getRemainingWeapons();
  const total = dbdata.length;
  const cleared = total - remaining.length;

  const title = document.getElementById("weaponPanelTitle");
  if(!title) return;

  title.innerHTML = `â— ë¬´ê¸° <span class="weapon-count">${cleared} / ${total}</span>`;
}

function activateOption(type, value){

  if(!value) return;

  const target = normalizeText(value);

  const buttons = document.querySelectorAll(`#${type} .btn`);

  buttons.forEach(btn=>{

    const btnValue = normalizeText(btn.textContent);

    if(btnValue === target){

      if(type === "primary"){

        if(!selected.primary.some(v => normalizeText(v) === target)){
          selected.primary.push(btn.textContent);
          btn.classList.add("active");
        }

      }else{
        selected[type] = btn.textContent;
        btn.classList.add("active");
      }
    }
  });
}

function resetSearchState(){

  // 1. ì„ íƒê°’ ì´ˆê¸°í™”
  lockedTargetWeapon = null;
  selected.primary = [];
  selected.secondary = null;
  selected.skill = null;
  selected.area = null;

  // 2. ë²„íŠ¼ active ì œê±°
  ["primary","secondary","skill","area"].forEach(type=>{
    document
      .querySelectorAll(`#${type} .btn`)
      .forEach(btn=>btn.classList.remove("active"));
  });

  // 3. ì¶”ì²œ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
  const guide = document.getElementById("weaponGuide");
  if(guide) guide.innerHTML="";

  // 4. ê²°ê³¼ì°½ ì´ˆê¸°í™”
  const result = document.getElementById("result");
  if(result) result.innerHTML="";

  // 5. ì˜µì…˜ ë¹„í™œì„±í™” ìƒíƒœ ë³µêµ¬
  updateOptionAvailability();
}

function resetAllSelections(){

  const types = ["primary","secondary","skill","area"];

  types.forEach(type=>{
    if(type==="primary"){
      selected.primary=[];
    }else{
      selected[type]=null;
    }

    document
      .querySelectorAll(`#${type} .btn`)
      .forEach(b=>b.classList.remove("active"));
  });
}

function calculateOptionBasedRecommendation(){

  const guide = document.getElementById("weaponGuide");
  if(!guide) return;

  // í˜„ì¬ ê²°ê³¼ ë¬´ê¸° ëª©ë¡
  if(!currentResult || currentResult.length === 0){
    guide.innerHTML="";
    return;
  }

  /* 1ï¸âƒ£ ì§€ì—­ë³„ ë¬´ê¸° ê·¸ë£¹í™” */
  const areaMap = {};

  currentResult.forEach(w=>{
    if(!w["ì§€ì—­"]) return;

    String(w["ì§€ì—­"])
      .split(',')
      .map(a=>normalizeText(a))
      .forEach(area=>{
        if(!areaMap[area]) areaMap[area]=[];
        areaMap[area].push(w);
      });
  });

  let bestArea=null;
  let bestScore=0;
  let bestSub=null;
  let bestStats=[];
  let bestStatCount={};
  let bestSubCount=0;

  /* 2ï¸âƒ£ ì§€ì—­ë³„ í‰ê°€ */
  Object.entries(areaMap).forEach(([area,weapons])=>{

    // ì˜µì…˜2+3 ë¹ˆë„ ê³„ì‚°
    const subCount={};

    weapons.forEach(w=>{
      [...parseOptions(w["ì˜µì…˜2"]),...parseOptions(w["ì˜µì…˜3"])]
      .forEach(opt=>{
        subCount[opt]=(subCount[opt]||0)+1;
      });
    });

    if(Object.keys(subCount).length===0) return;

    const sortedSub=Object.entries(subCount).sort((a,b)=>b[1]-a[1]);
    const subOpt=sortedSub[0][0];
    const subOptCount=sortedSub[0][1];  // â˜… ì¶”ê°€ (ì¤‘ìš”)

    // ê·¸ ì˜µì…˜ ê°€ì§„ ë¬´ê¸°ë§Œ
    const subWeapons=weapons.filter(w=>
      parseOptions(w["ì˜µì…˜2"]).includes(subOpt) ||
      parseOptions(w["ì˜µì…˜3"]).includes(subOpt)
    );

    // ì˜µì…˜1 í†µê³„
    const primaryCount={};
    subWeapons.forEach(w=>{
      parseOptions(w["ì˜µì…˜1"]).forEach(opt=>{
        primaryCount[opt]=(primaryCount[opt]||0)+1;
      });
    });

    const sortedPrimary=Object.entries(primaryCount).sort((a,b)=>b[1]-a[1]);
    if(!sortedPrimary.length) return;

    const cutoffIndex=Math.min(2,sortedPrimary.length-1);
    const cutoffScore=sortedPrimary[cutoffIndex][1];

    const topStats=sortedPrimary.filter(e=>e[1]>=cutoffScore);

    const statSet=new Set(topStats.map(e=>e[0]));

    // ì ìˆ˜ ê³„ì‚°
    const score=subWeapons.filter(w=>
      parseOptions(w["ì˜µì…˜1"]).some(opt=>statSet.has(opt))
    ).length;

    if(score>bestScore){
      bestScore=score;
      bestArea=area;
      bestSub=subOpt;
      bestSubCount=subOptCount;  // â˜… ì¶”ê°€
      bestStats=topStats;
      bestStatCount=primaryCount;
    }
  });

  if(!bestArea){
    guide.innerHTML="";
    return;
  }

  const statText=bestStats
    .map(e=>`${e[0]}(${e[1]})`)
    .join(", ");

  guide.innerHTML=`
  <b>ì¶”ì²œ ì§€ì—­:</b> ${bestArea} (${bestScore}ê°œ)<br>
  <b>ì¶”ì²œ ì˜µì…˜:</b> ${bestSub} (${bestSubCount})<br>
  <b>ì¶”ì²œ ìŠ¤íƒ¯:</b> ${statText}
  `;
}

function getTargetWeaponRecommendation(targetName){

  const target = dbdata.find(w=>w["ì´ë¦„"]===targetName);
  if(!target) return null;

  const targetAreas = String(target["ì§€ì—­"])
    .split(',')
    .map(a=>normalizeText(a));

  const targetSubOptions = [
    ...parseOptions(target["ì˜µì…˜2"]),
    ...parseOptions(target["ì˜µì…˜3"])
  ];

  let remaining = getRemainingWeapons();

  // íƒ€ê²Ÿì´ ì´ë¯¸ íšë“ ìƒíƒœì—¬ë„ ê³„ì‚°ì—ëŠ” í¬í•¨
  if(!remaining.some(w=>w["ì´ë¦„"]===targetName)){
    remaining = [...remaining, target];
  }

  let best = null;

  targetAreas.forEach(area=>{

    const areaWeapons = remaining.filter(w=>{
      if(!w["ì§€ì—­"]) return false;
      return String(w["ì§€ì—­"])
        .split(',')
        .map(a=>normalizeText(a))
        .includes(area);
    });

    if(areaWeapons.length===0) return;

    // â­ í•µì‹¬: íƒ€ê²Ÿ ì˜µì…˜ ê°ê°ì„ í›„ë³´ë¡œ í‰ê°€
    targetSubOptions.forEach(candidateOption=>{

      // 1ï¸âƒ£ í•´ë‹¹ ì˜µì…˜ ê°€ì§„ ë¬´ê¸°
      const subMatched = areaWeapons.filter(w=>
        parseOptions(w["ì˜µì…˜2"]).includes(candidateOption) ||
        parseOptions(w["ì˜µì…˜3"]).includes(candidateOption)
      );

      if(subMatched.length===0) return;

      // 2ï¸âƒ£ ì˜µì…˜1 í†µê³„
      const primaryCount={};
      subMatched.forEach(w=>{
        parseOptions(w["ì˜µì…˜1"]).forEach(opt=>{
          primaryCount[opt]=(primaryCount[opt]||0)+1;
        });
      });

      const sortedPrimary=Object.entries(primaryCount)
        .sort((a,b)=>b[1]-a[1]);

      if(sortedPrimary.length===0) return;

      // top3 (ë™ë¥  í¬í•¨ ì»·ë¼ì¸ ë°©ì‹)
      const cutoffIndex=Math.min(2,sortedPrimary.length-1);
      const cutoffScore=sortedPrimary[cutoffIndex][1];
      const topStats=sortedPrimary.filter(e=>e[1]>=cutoffScore);
      const statSet=new Set(topStats.map(e=>e[0]));

      // 3ï¸âƒ£ ì ìˆ˜: íƒ€ê²Ÿ ë°˜ë“œì‹œ í¬í•¨
      let score=0;
      subMatched.forEach(w=>{
        const match=parseOptions(w["ì˜µì…˜1"]).some(opt=>statSet.has(opt));
        if(match || w["ì´ë¦„"]===targetName) score++;
      });

      if(!best || score>best.score){
        best={
          area,
          option:candidateOption,
          stats:topStats,
          score
        };
      }

    });

  });

  return best;
}

function autoSelectOption(type, value){

  if(!value) return;

  // ê³µë°± ì œê±° ì •ê·œí™”
  const target = normalizeText(value).replace(/\s/g,'');

  const buttons = document.querySelectorAll(`#${type} .btn`);

  buttons.forEach(btn=>{

    const btnValue = normalizeText(btn.textContent).replace(/\s/g,'');

    // â­ ì™„ì „ì¼ì¹˜ë§Œ í—ˆìš© (í•µì‹¬ ìˆ˜ì •)
    if(btnValue === target){

  // disabled ìƒíƒœ ê°•ì œ í•´ì œ
  btn.classList.remove("disabled");

  toggle(type, btn.textContent, btn);
}
  });
}

function applyRecommendation(rec){

  if(!rec) return;

  resetAllSelections();

  // ìƒíƒœ ì„¸íŒ…
  forceSelect("area", rec.area);

  // â˜… ì—¬ê¸° í•µì‹¬
  const optionType = findOptionType(rec.option);
  if(optionType){
    forceSelect(optionType, rec.option);
  }

  rec.stats.forEach(stat=>{
    forceSelect("primary", stat[0]);
  });

  // â­â­â­ ì—¬ê¸° ì¶”ê°€ (ê°€ì¥ ì¤‘ìš”)
  syncButtonUI("area");
  syncButtonUI("secondary");
  syncButtonUI("skill");
  syncButtonUI("primary");

  // ë§ˆì§€ë§‰ ê³„ì‚°
  updateResult();
  updateOptionAvailability();
}

function forceSelect(type, value){

  if(!value) return;

  const normalized = normalizeText(value);

  // selected ìƒíƒœ ì§ì ‘ ì„¸íŒ…
  if(type === "primary"){
    if(!selected.primary.includes(value))
      selected.primary.push(value);
  }else{
    selected[type] = value;
  }

  // ë²„íŠ¼ UIë§Œ ì¼œê¸°
  document.querySelectorAll(`#${type} .btn`).forEach(btn=>{
    const btnValue = normalizeText(btn.textContent);

    if(btnValue === normalized){
      btn.classList.add("active");
      btn.classList.remove("disabled");
    }
  });
}

function syncButtonUI(type){

  document.querySelectorAll(`#${type} .btn`).forEach(btn=>{

    const value = normalizeText(btn.textContent);

    let isOn = false;

    if(type === "primary"){
      isOn = selected.primary.some(v => normalizeText(v) === value);
    }else{
      isOn = normalizeText(selected[type]) === value;
    }

    btn.classList.toggle("active", isOn);
    if(isOn) btn.classList.remove("disabled");
  });
}

function findOptionType(option){

  const normalized = normalizeText(option);

  // secondary ê²€ì‚¬
  const secondaryBtns = document.querySelectorAll("#secondary .btn");
  for(const btn of secondaryBtns){
    if(normalizeText(btn.textContent) === normalized){
      return "secondary";
    }
  }

  // skill ê²€ì‚¬
  const skillBtns = document.querySelectorAll("#skill .btn");
  for(const btn of skillBtns){
    if(normalizeText(btn.textContent) === normalized){
      return "skill";
    }
  }

  return null;
}

function getWeaponSimilarity(target, weapon){

  if(!target || !weapon) return 0;

  const targetOpts = [
    ...parseOptions(target["ì˜µì…˜2"]),
    ...parseOptions(target["ì˜µì…˜3"])
  ];

  const weaponOpts = [
    ...parseOptions(weapon["ì˜µì…˜2"]),
    ...parseOptions(weapon["ì˜µì…˜3"])
  ];

  // ê²¹ì¹˜ëŠ” ì˜µì…˜ ê°œìˆ˜
  let match = 0;

  targetOpts.forEach(opt=>{
    if(weaponOpts.includes(opt)) match++;
  });

  return match; // ê°’ì´ í´ìˆ˜ë¡ ìœ ì‚¬
}

function searchSort(a, b){

  /* â­ 0ìˆœìœ„ : ì„ íƒí•œ ê²€ìƒ‰ ë¬´ê¸° ë¬´ì¡°ê±´ ìµœìƒë‹¨ ê³ ì • */
  if(lockedTargetWeapon){
    if(a["ì´ë¦„"] === lockedTargetWeapon && b["ì´ë¦„"] !== lockedTargetWeapon) return -1;
    if(b["ì´ë¦„"] === lockedTargetWeapon && a["ì´ë¦„"] !== lockedTargetWeapon) return 1;
  }

  /* 1ï¸âƒ£ ì˜µì…˜ ìœ ì‚¬ë„ */
  let target = null;
  if(lockedTargetWeapon){
    target = dbdata.find(w => w["ì´ë¦„"] === lockedTargetWeapon);
  }

  if(target){
    const simA = getWeaponSimilarity(target, a);
    const simB = getWeaponSimilarity(target, b);

    if(simA !== simB){
      return simB - simA;
    }
  }

  /* 2ï¸âƒ£ ì„±ê¸‰ (6ì„± â†’ 5ì„±) */
  const gradeA = parseInt(a["ì„±ê¸‰"]);
  const gradeB = parseInt(b["ì„±ê¸‰"]);

  if(gradeA !== gradeB){
    return gradeB - gradeA;
  }

  /* 3ï¸âƒ£ íšë“ ì—¬ë¶€ (ë¯¸íšë“ ìš°ì„ ) */
  const ownedA = excludedIds.has(a["ì´ë¦„"]);
  const ownedB = excludedIds.has(b["ì´ë¦„"]);

  if(ownedA !== ownedB){
    return ownedA ? 1 : -1;
  }

  /* 4ï¸âƒ£ ì´ë¦„ìˆœ */
  return a["ì´ë¦„"].localeCompare(b["ì´ë¦„"], 'ko');
}

const toggleBtn = document.getElementById("sideToggle");
const sideInfo = document.querySelector(".side-info");

// ì €ì¥ëœ ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
if(localStorage.getItem("sideCollapsed") === "1"){
  sideInfo.classList.add("collapsed");
  toggleBtn.textContent = "â¯";
}

toggleBtn.onclick = ()=>{
  sideInfo.classList.toggle("collapsed");

  const collapsed = sideInfo.classList.contains("collapsed");

  toggleBtn.textContent = collapsed ? "â¯" : "â®";

  localStorage.setItem("sideCollapsed", collapsed ? "1" : "0");
};

document.addEventListener("DOMContentLoaded", () => {

  setActiveTab();

  const searchInput = document.getElementById("weaponSearch");

  if(searchInput){
    searchInput.addEventListener("focus", showUnownedList);
  }

});

</script>

</body>
</html>
